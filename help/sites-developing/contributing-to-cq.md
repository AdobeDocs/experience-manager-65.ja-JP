---
title: AEM への貢献
seo-title: AEM への貢献
description: AEM は、大規模なオープンソースのプロジェクトで一般的に実施される、実績ある方法に従って開発されます
seo-description: AEM は、大規模なオープンソースのプロジェクトで一般的に実施される、実績ある方法に従って開発されます
uuid: ffef60ae-8a9a-4c4b-8cbd-3cd72792a42e
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: introduction
content-type: reference
discoiquuid: f52402df-f6dc-4c62-82bc-cbce489b2b74
translation-type: tm+mt
source-git-commit: a3c303d4e3a85e1b2e794bec2006c335056309fb

---


# AEM への貢献{#contributing-to-aem}

## 開発方法 {#development-methodology}

AEM は、大規模なオープンソースのプロジェクトで一般的に実施される、実績ある方法に従って開発されます。AEM のテクノロジースタックの多くのコア要素は、実際は Sling や Jackrabbit のようなアクティブなオープンソースプロジェクトとして保守され、Apache Software Foundation に貢献しました。AEM に存在するこの精神における重要な側面は、利用可能なメーリングリストやオンラインフォーラムを活用した開発チームとの直接のやり取りが奨励されているということです。

AEM のコンポーネントに貢献する場合は、オープンソースプロジェクトに貢献する場合と同様に AEM に関する知識を深め、このようなプロジェクトに貢献しようとする場合と同様に既存のコアチームとコミュニケーションを取る必要があります。

## 必要な経験 {#required-experience}

HyperText Transfer Protocol（HTTP）は、すべての作業の中心となります。したがって、AEM に貢献する前に、HTTP について深く理解する必要があります。スレッドプーリングを使用してマルチスレッド HTTP サーバーの Java 実装を独自で記述できるレベルが理想です。また、HTTP/1.1 のキープアライブ動作についても理解する必要があり、JavaScript によるサーバー／クライアント側のインタラクション、特に、AJAX によって表現される非同期スタイルのインタラクションに関する深い知識も必要です。

ページダイナミズムとインタラクティブなコンテンツが WM 体験では重要なので、Document Object Model について、またこれを使用してイベントに対する応答をプログラムによって操作する可能性についても、かなり深く理解しておくことが不可欠です。例えば、リアルタイムの DOM 操作や、複数のブラウザードキュメントにまたがったドラッグ＆ドロップ動作（iframe を使用するなど）についても、ある程度の知識が必要です。

最高レベルでは、以下について確実に理解する必要があります。

* [HTTP/1.1 プロトコル](https://www.ietf.org/rfc/rfc2616.txt)
* HTML（[HTML5](https://dev.w3.org/html5/spec/Overview.html) が望ましい）
* カスケーディングスタイルシート
* Extensible Markup Language（XML）
* Asynchronous JavaScript and XML（AJAX）設計パターン
* JavaScript Object Notation（JSON）
* Document Object Model
* ステートフルインタラクションとステートレスインタラクション
* [Uniform Resource Identifier](https://www.ietf.org/rfc/rfc2396.txt)
* ブラウザーの cookie
* その他の最新の Web 開発概念

The technology stack of Adobe Experience Manager are based on the [Apache Felix](https://felix.apache.org/) OSGI container with the [Apache Sling](https://sling.apache.org/site/index.html) web framework and embeds a Java Content Repository ([JCR](https://docs.adobe.com/content/docs/en/spec/jcr/2.0/index.html)) based on [Apache Jackrabbit](https://jackrabbit.apache.org/jcr-api.html). You should familiarize yourself with these individual projects, as well as any other open source components (e.g., Apache Lucene) used in the area where you intend to contribute.

## 業界知識 {#tribal-knowledge}

一定の概念や指針は、以前の Day 社の文化に深く根ざしています。ここでは、「DNA に深く埋め込まれている」問題の中で注意すべきものをいくつか示します。

### すべてがコンテンツである {#everything-is-content}

コンテンツには、Webアプリケーションが保持するすべてのデータだけでなく、プログラムコード、ライブラリ、スクリプト、テンプレート、HTML、CSS、画像、アーティファクトなど、あらゆるものは、Content Repositoryに保持され、Package ManagerとPackage shareを使用してパッケージの形式で読み込み/書き出されます。

### David&#39;s Model {#david-s-model}

The way content should be modeled in a Java Content Repository requires an entirely different way of thinking than what is common practice in the software industry for data modeling in the relational world. Essential reading for any newcomer to content management the JCR way is [David&#39;s Model: A guide for content modeling](https://wiki.apache.org/jackrabbit/DavidsModel).

### RESTful であること {#restfulness}

REST アプローチは、作業内容に深く根ざしています。つまり、何よりも、ステートフルなインタラクションを回避すること、また、URI がコンテンツおよびサービスの確定的なアドレスであることを心に留めておくことです。

REST（REpresentational State Transfer）は、World Wide Web の基礎となっているソフトウェアアーキテクチャスタイルを示します。Web を機能させるための重要な要素について説明するものであり、Web ベースのソフトウェアの設計方法について一連の原則を提供します。したがって、Web 経由で使用する API を設計するときは、これらの「ベストプラクティス」を順守することが合理的です。

REST は非常に多くの作業の背景に指針となる考え方を提供するので、RESTful な設計の教義を熟知しておくことが不可欠と考える必要があります。手始めとしてふさわしいのは、[Roy Fielding 氏の論文](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)です。

### Sling の要求解決 {#sling-request-resolution}

AEM について理解する上で重要な点は、受信要求がコンテンツおよびアプリケーションの動作とどのように関連付けられるか、コンテンツリポジトリでのコンテンツの構造、および要求処理のためのアプリケーションロジックを AEM がどこで検索するかです。Apache [Sling の URL の分解](https://sling.apache.org/site/url-decomposition.html)について、また、REST アーキテクチャスタイルおよびそのステートレスでキャッシュ可能な階層化システムの制約を実施する方法について学習してください。

Apache Sling の要求解決に関しては、コンテンツリポジトリの特定のリソースに要求が最初にマップする方法、コンテンツをレンダリングする際にどのアプリケーションコードを呼び出すかを要求する追加プロパティとこれらのコンテンツオブジェクトのプロパティによって決定する方法、および /apps 内のコードで /libs 内のコードを上書きする方法を理解することが重要です。

### クイックスタート {#quickstart}

手順 3 がない：インストールして実行するには、クイックスタート JAR ファイルをダウンロードしてダブルクリックするだけです。手順 3 はありません。オプションの機能を追加する場合も、パッケージ共有から該当するパッケージをインストールするだけです。

クイックスタートサイズ（小）:Quickstart JARファイルのサイズは最小限に抑えます。ライブラリの使用を最適化し、オプション機能をパッケージ共有に移行します。

起動時間が短い：起動時間に影響する可能性のある変更をおこなう場合は、長くなるのではなく、短くなるようにします。

### 無駄なくすっきり {#lean-and-mean}

アドビでは、軽量でサイズが小さく、高速かつ洗練されたコードやプロジェクトを優先します。「十分に良い」では本当に十分ではありません。

コードの再利用：OSGi ベースの製品アーキテクチャと「すべてがコンテンツである」という考え方は、コードおよびアーティファクトを再利用する、いつにない好機が与えられているということを意味します。アドビでは、この事実を可能な限り利用して、無駄なくすっきりした機能を維持しようとしています。

疎結合：アドビでは、厳密な依存関係や「不要な密接さ」よりも、疎結合のインタラクションを優先します。疎結合により、より多くのコードの再利用も可能になります。

### デモを無効にしない {#don-t-break-the-demo}

デモで最も頻繁に表示されるデモスクリプトや製品機能について理解してください。「デモスクリプト」機能を中断すべきことは、少なくとも何もしないことを理解してください。コア製品は、開発中でも、必ずデモに対応する必要があります。

### 信頼できる設計 {#design-for-reliability}

アドビでは、フェイルソフトな方法で機能を設計およびコード化するよう努めています。これにより、例えば 1 つの DOM 要素の問題が原因でページ全体がレンダリングされなくなることはありません。つまり、致命的とするべきことは致命的とし、その他はすべて存続可能にして、製品を「寛容に」するということです。

### 異常は新たな正常 {#abnormal-is-the-new-normal}

シャットダウンフックに依存しないで、起動時にクリーンアップを確認します。異常終了は正常終了です。

`shutdown == kill -9 == power outage`

### 弾性クラスター化に備える {#be-ready-for-elastic-clustering}

弾性クラスタリングの準備は常に整っておき、常にクラスタリングがあると仮定します。原則として、コンテンツリポジトリ内のすべての要素に従うことは、クラスタリングのサポートを組み込むことを意味します。

### 下位互換性に対応する設計 {#design-for-backward-compatibility}

顧客の古いコードを破る必要はありません。 アップグレード `/libs` 時に更新できる製品コードのみを含めることを検討します。 リポジトリ `/apps` のセクションはプロジェクトコードで、セクションには保 `/etc` 持する必要があるカスタム設定が含まれています。 一般に、およびでは何も上書きしな `/apps`いでく `/content` ださ `/home`い。 アップグレード後も、古いプロジェクトコード、設定、およびコンテンツは、アップグレード前と同じように引き続き機能します。

また、後方互換性を考慮した設計により、初期インストールのシンプルさに合わせてアップグレードエクスペリエンスを向上させることができます。AEMを停止し、Quickstart JARファイルを置き換えて、AEMを再び起動するだけで十分です。急速に成長するインストール・ベースにより、アップグレードの効率性がますます大きなメリットとなります。

より新しく、より高度な機能に置き換えられると、既存の API は廃止とマークを付けることができ、またそうする必要がありますが、以前の 5.x リリースで公開された API はすべて、カスタムアプリケーションコードで使用される可能性があるので、引き続き機能する必要があります。そのような API は削除しないでください。

下位互換性は、コンテンツ構造とユーザー体験の全体的な一貫性という意味でも、心に留めておく必要があります。

## 中心概念 {#core-concepts}

**作成者インスタンス** — 通常、セキュリティ、ガバナンス、その他の理由から、実稼働サイトではAEMのインスタンスを作成者インスタンスと発行インスタンスに分割します。 デプロイメントアーキテクチャ（作成者/発行インスタンスを含む）について詳しくは、AEMインスタンスに関するドキュメントを参照してください。

**キャッシュ、フライ** 、ベーク処理：従来、ベイク処理とフライ処理の概念は、異なるWebコンテンツ管理システム間で重要な区別となっていました。 CMSの用語では、「焼き付け」とは公開時にデータを静的ファイルにコミットする概念を指し、「焼き付け」とは要求時（即時）に最終的なプレゼンテーション用にデータを処理する概念を指します。

**クラスタリングとロードバランシング** — 可用性を向上させ、実稼働環境のパフォーマンスを向上させるには、複数の作成者インスタンスと発行インスタンスを（クラスターに）組み合わせるか、様々なグループのユーザーに使用させるか、ディスパッチャー設定の後ろでロードバランシングを行います。

It is also possible to combine multiple instances of the content repository to create a *high-availability* JCR solution, which can then be integrated with your AEM solution to maximize protection against hardware and software failure. 詳しくは、[推奨されるデプロイメント](/help/sites-deploying/recommended-deploys.md#oak-cluster-with-mongomk-failover-for-high-availability-in-a-single-datacenter)を参照してください。

**コンポーネント** - AEMでは、コンポーネントはオブジェクトタイプで、通常、サイドキックなどからドラッグ&amp;ドロップすることで作成できます。 例えば、AEMに付属の標準コンポーネントには、テキスト、タイトル、タグクラウド、カルーセル、画像、リストの各コンポーネントが含まれ、これらはすべて実行時にサイドキックから利用できます。

**コンテンツファインダー** — オーサリングモードでは、コンテンツファインダーはページの左側の特別なパネル（フレーム）で、上部で選択したタブに応じて、コンテンツファインダーから作業中のページ（右側）にドラッグ&amp;ドロップできる画像、ドキュメント、Flashアセット、ページ、段落またはリポジトリリソースのリストを表示します。

**デジタルアセット** - AEMでは、デジタルアセットは（通常）画像およびリッチメディアファイルです。 詳しくは、DAMでのデジタルアセットの操作を参照してください。

**ディスパッチャー** — ディスパッチャーは、キャッシュとロードバランシングの両方のツールであり、特定のセキュリティ保護を提供します。

**ExtJSウィジェット** - AEMのほとんどのユーザーインターフェイス要素は、JavaScriptで記述されたサードパーティのウィジェットライブラリであるExtJSを使用します。 ExtJSは、高パフォーマンスでカスタマイズ可能なUIウィジェットと、設計が良く拡張可能なコンポーネントモデルを備えています。

**JCR、Java Content Repository** - Java Content Repository仕様(JSR-283)は、抽象データモデルとアプリケーションプログラミングインターフェイスの両方を提供し、ファイルシステムの機能とオブジェクトデータベースを組み合わせた、強力なスケーラブルなNoSQLデータリポジトリを実現します。 JSR-283を詳しく理解する必要はありませんが、JCRがAEMの「すべてはコンテンツ」哲学を可能にする理由なので、JCRの基本的な機能とその基礎となるデータモデルを理解するには時間がかかります。

本質的に、JCR はノードとプロパティのシステムであり、ノードは他のノードからの継承が可能で、すべてのコンテンツはプロパティの値として格納されます。**&#x200B;通常の継承に加えて、JCR は「mixin」ノードの概念に対応しており、複数の継承をモデル化できます。

JCR には事前に定義されたノードタイプおよびプロパティタイプが多数含まれていますが、一般的にタイピングシステムは非常に柔軟です。実際に、JCR の長所の 1 つは、構造化コンテンツも非構造化コンテンツも同じくらい簡単に格納および管理できることです。つまり、JCR には高度に構造化されたデータを含めることができますが、任意の動的データ構造もスキーマ制約なしで含めることができます。

JCR の Java API に関する JavaDoc は、[こちら](http://jackrabbit.apache.org/jcr/jcr-api.html)を参照してください。

JavaDoc または JCR の仕様自体を読む前に、Adobe Experience Services によって実装された JCR の[概要](/help/sites-developing/the-basics.md#java-content-repository)にも目を通しておくことをお勧めします。

**マルチサイトマネージャー(MSM)** - AEMのMSM機能は、多言語および多国間コンテンツの処理を支援し、一元化されたブランディングとローカライズされたコンテンツのバランスをとることができます。

**OSGi** - OSGiは、AEMでモジュール化されたJava開発の基盤を提供するサービスベースのランタイムテクノロジーです。 これは、コードリソース（バンドルと呼ばれる）の高度に動的な（安全な）クラス読み込みおよび実行環境だけでなく、バンドルによって公開される各種サービスの可視性とライフサイクルを完全に制御するフレームワークです。 サービスレジストリは、ライフサイクルダイナミクス（およびバージョン要件）を考慮したバンドルの連携モデルを提供します。 OSGiは、アプリケーションサーバーが解決しようとしていた多くの問題を解決しますが、軽量で非常に動的な方法で解決し、サービスのホットデプロイ（サーバーを再起動せずに新しいコードを即座に利用可能にする）などを可能にします。

**Parsys, Paragraph System** — 段落システム(parsys)は、異なるタイプのコンポーネントをページに追加し、他の段落コンポーネントを含む複合コンポーネントです。 それぞれの段落タイプはコンポーネントとして表されます。段落システム自体もコンポーネントであり、他の段落コンポーネントが含まれます。

**Microkernel** — リポジトリ内のすべてのワークスペースは、特定のマイクロカーネル（データの読み書きを管理するクラス）を介してデータを保存するように個別に設定できます。 同様に、リポジトリレベルのバージョンストアも、特定のマイクロカーネルを使用するように、個別に設定できます。使用できるマイクロカーネルは多数あります。異なるマイクロカーネルを使用すると、様々なファイル形式やリレーショナルデータベースへのデータ保存に対応できます（例えば、MongoDB、DB2 または Oracle 用の永続性マネージャーがあります）。AEM 用のデフォルトのマイクロカーネルは TarMK です（後述）。

**発行インスタンス** — セキュリティ、ガバナンス、その他の理由から、実稼働サイトでは通常、AEMのインスタンスを作成者インスタンスと発行インスタンスに分割します。 デプロイメントアーキテクチャ（作成者/発行インスタンスを含む）について詳しくは、AEMインスタンスに関するドキュメントを参照してください。

**Quickstart** — 他の多くのプログラムとは異なり、自己解凍型のJARファイルを1つ使用してAEMをインストールします。 JARファイルを初めてダブルクリックすると、必要なすべてが自動的にインストールされます。 クイックスタートJARには、CRXリポジトリ（管理施設を含む）、仮想リポジトリサービス、インデックスおよび検索サービス、ワークフローサービス、セキュリティ、Webサーバーに必要なすべてのファイルに加え、CQサーブレットエンジン(CQSE)とすべてのAEMサービスが含まれます。 インストールするファイルは他にありません：クイックスタートは自己完結型です。

クイックスタートを初めて起動すると、JCR 対応のリポジトリ全体がバックグランドで作成されます。この処理に数分かかる場合があります。この初期起動が完了すると、リポジトリのインフラストラクチャは既に設定されているので、その後の起動処理はごく短時間で済みます。

多くの起動オプション（アクティブなポート番号、問題の AEM インスタンスをパブリッシュインスタンスとオーサーインスタンスのどちらにするか、など）は、クイックスタートファイルの名前を適宜変更することによって制御できます。この点に関するオプションのリストを確認するには、次のように、コマンドラインで「-help」を付けて JAR を実行します。

```shell
java -jar <quickstartfilename>.jar -help
```

**複製エージェント** — 複製エージェントは、作成者から発行環境にコンテンツを発行（アクティブ化）するメカニズムとして、AEMの中心となるものです。ディスパッチャーキャッシュからコンテンツをフラッシュする。発行環境から作成者環境に、ユーザー生成コンテンツ（例えば、フォーム入力）を返します。

**スキャフォールド** — スキャフォールドを使用すると、ページに必要な構造を反映したフィールドを持つフォーム（スキャフォールド）を作成し、このフォームを使用して、この構造に基づいたページを簡単に作成できます。

**セグメント** — サイト訪問者がサイトに来たときの興味と目標は異なります。 訪問者の目標を把握し、期待を満たすことは、オンラインマーケティングの重要な成功の前提条件です。 セグメント化によって訪問者の詳細を分析し、特徴付けることが成功の実現に役立ちます。

**サイドキック** — サイドキックは、編集可能なページに表示されるパレットのようなフローティングウィンドウで、新しいコンポーネントをドラッグして、ページに適用するアクションを実行できます。

**Site Catalyst** - SiteCatalystは、複数のマーケティングチャネルにわたるすべてのオンラインイニシアチブからの統合データを1か所で測定、分析、最適化できます。 Adobe siteCatalystを使用して、AEM webサイトからのデータを分析できます。

**Tar Storage (TarMK)** - tarMKはAEMのデフォルトの永続性システムです。 AEM は、異なる永続化システム（MongoDB など）を使用するように設定できますが、TarMK には、一般的な JCR の使用例向けにパフォーマンスが最適化されており（そのため、非常に高速）、業界標準のデータ形式を使用し、すばやく簡単にバックアップできるという点で明白なメリットがあります。

**テンプレート** - AEMでは、テンプレートは特定のタイプのページを指定します。 ページの構造を定義します（一方、通常はサムネール画像と様々なプロパティも指定します）。 例えば、製品ページ、サイトマップおよび問い合わせ先に、それぞれ別のテンプレートを使用することができます。

**ワークフロー** - AEM Workflowシステムを使用すると、ページやアセットを含む自動プロセスを作成できます。
