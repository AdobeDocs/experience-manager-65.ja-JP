---
title: AEM への貢献
seo-title: AEM への貢献
description: AEM は、大規模なオープンソースのプロジェクトで一般的に実施される、実績ある方法に従って開発されます
seo-description: AEM は、大規模なオープンソースのプロジェクトで一般的に実施される、実績ある方法に従って開発されます
uuid: ffef60ae-8a9a-4c4b-8cbd-3cd72792a42e
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: introduction
content-type: reference
discoiquuid: f52402df-f6dc-4c62-82bc-cbce489b2b74
translation-type: tm+mt
source-git-commit: a3c303d4e3a85e1b2e794bec2006c335056309fb
workflow-type: tm+mt
source-wordcount: '2726'
ht-degree: 48%

---


# AEM への貢献{#contributing-to-aem}

## 開発方法 {#development-methodology}

AEM は、大規模なオープンソースのプロジェクトで一般的に実施される、実績ある方法に従って開発されます。AEM のテクノロジースタックの多くのコア要素は、実際は Sling や Jackrabbit のようなアクティブなオープンソースプロジェクトとして保守され、Apache Software Foundation に貢献しました。AEM に存在するこの精神における重要な側面は、利用可能なメーリングリストやオンラインフォーラムを活用した開発チームとの直接のやり取りが奨励されているということです。

AEM のコンポーネントに貢献する場合は、オープンソースプロジェクトに貢献する場合と同様に AEM に関する知識を深め、このようなプロジェクトに貢献しようとする場合と同様に既存のコアチームとコミュニケーションを取る必要があります。

## 必要な経験 {#required-experience}

HyperText Transfer Protocol（HTTP）は、すべての作業の中心となります。したがって、AEM に貢献する前に、HTTP について深く理解する必要があります。スレッドプーリングを使用してマルチスレッド HTTP サーバーの Java 実装を独自で記述できるレベルが理想です。また、HTTP/1.1 のキープアライブ動作についても理解する必要があり、JavaScript によるサーバー／クライアント側のインタラクション、特に、AJAX によって表現される非同期スタイルのインタラクションに関する深い知識も必要です。

ページダイナミズムとインタラクティブなコンテンツが WM 体験では重要なので、Document Object Model について、またこれを使用してイベントに対する応答をプログラムによって操作する可能性についても、かなり深く理解しておくことが不可欠です。例えば、リアルタイムの DOM 操作や、複数のブラウザードキュメントにまたがったドラッグ＆ドロップ動作（iframe を使用するなど）についても、ある程度の知識が必要です。

最高レベルでは、以下について確実に理解する必要があります。

* [HTTP/1.1 プロトコル](https://www.ietf.org/rfc/rfc2616.txt)
* HTML（[HTML5](https://dev.w3.org/html5/spec/Overview.html) が望ましい）
* カスケーディングスタイルシート
* Extensible Markup Language（XML）
* Asynchronous JavaScript and XML（AJAX）設計パターン
* JavaScript Object Notation（JSON）
* Document Object Model
* ステートフルインタラクションとステートレスインタラクション
* [Uniform Resource Identifier](https://www.ietf.org/rfc/rfc2396.txt)
* ブラウザーの cookie
* その他の最新の Web 開発概念

The technology stack of Adobe Experience Manager are based on the [Apache Felix](https://felix.apache.org/) OSGI container with the [Apache Sling](https://sling.apache.org/site/index.html) web framework and embeds a Java Content Repository ([JCR](https://docs.adobe.com/content/docs/en/spec/jcr/2.0/index.html)) based on [Apache Jackrabbit](https://jackrabbit.apache.org/jcr-api.html). You should familiarize yourself with these individual projects, as well as any other open source components (e.g., Apache Lucene) used in the area where you intend to contribute.

## 業界知識 {#tribal-knowledge}

一定の概念や指針は、以前の Day 社の文化に深く根ざしています。ここでは、「DNA に深く埋め込まれている」問題の中で注意すべきものをいくつか示します。

### すべてがコンテンツである {#everything-is-content}

コンテンツには、Webアプリケーションが保持するすべてのデータだけでなく、あらゆる種類のプログラムコード、ライブラリ、スクリプト、テンプレート、HTML、CSS、画像、アーティファクトは、すべてContent Repositoryに保持され、Package ManagerとPackage Shareを介してパッケージの形式で読み込み/書き出されます。

### David&#39;s Model {#david-s-model}

The way content should be modeled in a Java Content Repository requires an entirely different way of thinking than what is common practice in the software industry for data modeling in the relational world. Essential reading for any newcomer to content management the JCR way is [David&#39;s Model: A guide for content modeling](https://wiki.apache.org/jackrabbit/DavidsModel).

### RESTful であること {#restfulness}

REST アプローチは、作業内容に深く根ざしています。つまり、何よりも、ステートフルなインタラクションを回避すること、また、URI がコンテンツおよびサービスの確定的なアドレスであることを心に留めておくことです。

REST（REpresentational State Transfer）は、World Wide Web の基礎となっているソフトウェアアーキテクチャスタイルを示します。Web を機能させるための重要な要素について説明するものであり、Web ベースのソフトウェアの設計方法について一連の原則を提供します。したがって、Web 経由で使用する API を設計するときは、これらの「ベストプラクティス」を順守することが合理的です。

REST は非常に多くの作業の背景に指針となる考え方を提供するので、RESTful な設計の教義を熟知しておくことが不可欠と考える必要があります。手始めとしてふさわしいのは、[Roy Fielding 氏の論文](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)です。

### Sling の要求解決 {#sling-request-resolution}

AEM について理解する上で重要な点は、受信要求がコンテンツおよびアプリケーションの動作とどのように関連付けられるか、コンテンツリポジトリでのコンテンツの構造、および要求処理のためのアプリケーションロジックを AEM がどこで検索するかです。Apache [Sling の URL の分解](https://sling.apache.org/site/url-decomposition.html)について、また、REST アーキテクチャスタイルおよびそのステートレスでキャッシュ可能な階層化システムの制約を実施する方法について学習してください。

Apache Sling の要求解決に関しては、コンテンツリポジトリの特定のリソースに要求が最初にマップする方法、コンテンツをレンダリングする際にどのアプリケーションコードを呼び出すかを要求する追加プロパティとこれらのコンテンツオブジェクトのプロパティによって決定する方法、および /apps 内のコードで /libs 内のコードを上書きする方法を理解することが重要です。

### クイックスタート {#quickstart}

手順 3 がない：インストールして実行するには、クイックスタート JAR ファイルをダウンロードしてダブルクリックするだけです。手順 3 はありません。オプションの機能を追加する場合も、パッケージ共有から該当するパッケージをインストールするだけです。

小さいクイックスタートサイズ：Quickstart JARファイルのサイズを最小限に抑えます。ライブラリを最適化してスマートに使用し、オプションの機能をパッケージ共有に移動。

起動時間が短い：起動時間に影響する可能性のある変更をおこなう場合は、長くなるのではなく、短くなるようにします。

### 無駄なくすっきり {#lean-and-mean}

アドビでは、軽量でサイズが小さく、高速かつ洗練されたコードやプロジェクトを優先します。「十分に良い」では本当に十分ではありません。

コードの再利用：OSGi ベースの製品アーキテクチャと「すべてがコンテンツである」という考え方は、コードおよびアーティファクトを再利用する、いつにない好機が与えられているということを意味します。アドビでは、この事実を可能な限り利用して、無駄なくすっきりした機能を維持しようとしています。

疎結合：アドビでは、厳密な依存関係や「不要な密接さ」よりも、疎結合のインタラクションを優先します。疎結合により、より多くのコードの再利用も可能になります。

### デモを無効にしない {#don-t-break-the-demo}

デモで最もよく表示されるデモスクリプトと製品機能について理解します。少なくとも、「デモスクリプト」機能を中断すべきことは何もしないことを理解してください。コア製品は、開発中でも、必ずデモに対応する必要があります。

### 信頼できる設計 {#design-for-reliability}

アドビでは、フェイルソフトな方法で機能を設計およびコード化するよう努めています。これにより、例えば 1 つの DOM 要素の問題が原因でページ全体がレンダリングされなくなることはありません。つまり、致命的とするべきことは致命的とし、その他はすべて存続可能にして、製品を「寛容に」するということです。

### 異常は新たな正常 {#abnormal-is-the-new-normal}

シャットダウンフックに依存しないでください。起動時にクリーンアップを行ってください。異常終了は正常終了です。

`shutdown == kill -9 == power outage`

### 弾性クラスター化に備える {#be-ready-for-elastic-clustering}

弾性クラスタリングに対する準備は常に整っておき、常にクラスタリングがあると考えてください。原則として、コンテンツリポジトリ内のすべての要素に従うことは、クラスタリングのサポートを組み込むことを意味します。

### 下位互換性に対応する設計 {#design-for-backward-compatibility}

お客様の古いコードを破る必要はありません。 アップグレード `/libs` 時に更新できる製品コードのみを含めることを検討してください。 リポジトリの `/apps` セクションはプロジェクトコードで、 `/etc` セクションには保存する必要があるカスタム設定が含まれています。 一般に、およびでは何も上書きしな `/apps`いでく `/content` ださい `/home`。 アップグレード後も、古いプロジェクトコード、設定、およびコンテンツは、アップグレード前と同様に機能し続ける必要があります。

後方互換性を確保するための設計により、初回インストール時のシンプルさに合わせてアップグレードを行うこともできます。AEMを停止し、Quickstart JARファイルを置き換えて、AEMを再起動するだけで十分です。急速に成長するインストール・ベースにより、アップグレードの効率性はますます大きなメリットとなります。

より新しく、より高度な機能に置き換えられると、既存の API は廃止とマークを付けることができ、またそうする必要がありますが、以前の 5.x リリースで公開された API はすべて、カスタムアプリケーションコードで使用される可能性があるので、引き続き機能する必要があります。そのような API は削除しないでください。

下位互換性は、コンテンツ構造とユーザー体験の全体的な一貫性という意味でも、心に留めておく必要があります。

## 中心概念 {#core-concepts}

**作成者インスタンス** — 通常、セキュリティ、ガバナンス、その他の理由から、実稼働サイトではAEMのインスタンスが作成者インスタンスと発行インスタンスに分割されます。 デプロイメントアーキテクチャ（作成者/発行インスタンスを含む）について詳しくは、AEMインスタンスに関するドキュメントを参照してください。

**キャッシュ、フライ、ベーキング** — 従来、ベーキングとフライの概念は、異なるWebコンテンツ管理システム間で重要な違いです。 CMSの用語では、「ベイク処理」とは、公開時に静的ファイルにデータをコミットする概念を指し、「フライ」とは要求時（即時）に最終的なプレゼンテーション用にデータを処理する概念を指します。

**クラスタリングとロードバランシング** — 可用性を高め、実稼働環境のパフォーマンスを向上させるために、複数の作成者インスタンスと発行インスタンスを様々なグループで使用するか、ディスパッチャー設定の背後でロードバランシングを行うことが一般的です。

It is also possible to combine multiple instances of the content repository to create a *high-availability* JCR solution, which can then be integrated with your AEM solution to maximize protection against hardware and software failure. 詳しくは、[推奨されるデプロイメント](/help/sites-deploying/recommended-deploys.md#oak-cluster-with-mongomk-failover-for-high-availability-in-a-single-datacenter)を参照してください。

**コンポーネント** - AEMでは、コンポーネントはオブジェクトタイプで、通常、サイドキックなどからコンポーネントのインスタンスをドラッグ&amp;ドロップすることで作成できます。 例えば、AEMに付属の標準コンポーネントには、テキスト、タイトル、タグクラウド、カルーセル、画像、リストの各コンポーネントが含まれ、すべて実行時にサイドキックから利用できます。

**コンテンツファインダー** — オーサリングモードでは、コンテンツファインダーはページの左側の特別なパネル（フレーム）です。上部で選択したタブに応じて、コンテンツファインダーからドラッグ&amp;ドロップできるリスト、ドキュメント、Flashアセット、ページ、段落またはリポジトリリソースが表示されます。

**デジタルアセット** - AEMでは、デジタルアセットは画像およびリッチメディアファイルです（通常）。 詳しくは、「DAMでのデジタルアセットの操作」を参照してください。

**ディスパッチャー** — ディスパッチャーは、キャッシュおよびロードバランシングのツールであり、特定のセキュリティ保護機能を提供します。

**ExtJSウィジェット** - AEMのほとんどのユーザーインターフェイス要素は、JavaScriptで記述されたサードパーティのウィジェットライブラリであるExtJSを使用します。 ExtJSは、高パフォーマンスでカスタマイズ可能なUIウィジェットと、設計が良く拡張可能なコンポーネントモデルを備えています。

**JCR、Java Content Repository** - Java Content Repository仕様(JSR-283)は、抽象データモデルとアプリケーションプログラミングインターフェイスの両方を提供し、ファイルシステムの機能とオブジェクトデータベースを組み合わせた大規模なスケーラブルなNoSQLデータリポジトリを実現します。 JSR-283を徹底的に理解する必要はありませんが、AEMの「すべてはコンテンツ」哲学を可能にするのはJCRの基本的な能力とその基礎となるデータモデルを理解するのに時間がかかるはずです。

本質的に、JCR はノードとプロパティのシステムであり、ノードは他のノードからの継承が可能で、すべてのコンテンツはプロパティの値として格納されます。**&#x200B;通常の継承に加えて、JCR は「mixin」ノードの概念に対応しており、複数の継承をモデル化できます。

JCR には事前に定義されたノードタイプおよびプロパティタイプが多数含まれていますが、一般的にタイピングシステムは非常に柔軟です。実際に、JCR の長所の 1 つは、構造化コンテンツも非構造化コンテンツも同じくらい簡単に格納および管理できることです。つまり、JCR には高度に構造化されたデータを含めることができますが、任意の動的データ構造もスキーマ制約なしで含めることができます。

JCR の Java API に関する JavaDoc は、[こちら](http://jackrabbit.apache.org/jcr/jcr-api.html)を参照してください。

JavaDoc または JCR の仕様自体を読む前に、Adobe Experience Services によって実装された JCR の[概要](/help/sites-developing/the-basics.md#java-content-repository)にも目を通しておくことをお勧めします。

**マルチサイトマネージャ(MSM)** - AEMのMSM機能は、多言語コンテンツと多言語コンテンツの処理に役立ち、ローカライズされたコンテンツとの一元管理のバランスをとることができます。

**OSGi** - OSGiは、AEMでモジュール化されたJava開発の基盤を提供するサービスベースのランタイムテクノロジです。 これは、非常に動的（安全）なクラスの読み込みと実行の環境をコードリソース（バンドルと呼ばれます）に提供するだけでなく、バンドルによって公開される様々なサービスの表示とライフサイクルを完全に制御するフレームワークです。 サービスレジストリは、ライフサイクルダイナミクス（およびバージョン要件）を考慮したバンドルの連携モデルを提供します。 OSGiは、アプリケーションサーバーが解決しようとしていた問題の多くを解決しますが、軽量で動的な方法で解決します。たとえば、サーバーを再起動せずに新しいコードを即座に使用可能にするなどの方法が可能です。

**Parsys, Paragraph System** — 段落システム(parsys)は、異なる種類のコンポーネントをページに追加し、他の段落コンポーネントを含めることを可能にする複合コンポーネントです。 それぞれの段落タイプはコンポーネントとして表されます。段落システム自体もコンポーネントであり、他の段落コンポーネントが含まれます。

**Microkernel** — リポジトリ内の各ワークスペースは、特定のマイクロカーネル（データの読み取りと書き込みを管理するクラス）を介してデータを格納するように個別に設定できます。 同様に、リポジトリレベルのバージョンストアも、特定のマイクロカーネルを使用するように、個別に設定できます。使用できるマイクロカーネルは多数あります。異なるマイクロカーネルを使用すると、様々なファイル形式やリレーショナルデータベースへのデータ保存に対応できます（例えば、MongoDB、DB2 または Oracle 用の永続性マネージャーがあります）。AEM 用のデフォルトのマイクロカーネルは TarMK です（後述）。

**発行インスタンス** — セキュリティ、ガバナンス、その他の理由から、実稼働サイトでは通常、AEMのインスタンスを作成者インスタンスと発行インスタンスに分割します。 デプロイメントアーキテクチャ（作成者/発行インスタンスを含む）について詳しくは、AEMインスタンスに関するドキュメントを参照してください。

**クイックスタート** — 他の多くのプログラムとは異なり、AEMをインストールするには、自己解凍型のJARファイルを1つ使用します。 JARファイルを初めて重複クリックすると、必要なすべてが自動的にインストールされます。 quickstart JARには、CRXリポジトリ（管理施設を含む）、仮想リポジトリサービス、インデックスと検索サービス、ワークフローサービス、セキュリティ、Webサーバーに必要なすべてのファイルに加え、CQサーブレットエンジン(CQSE)とすべてのAEMサービスが含まれます。 インストールするファイルは他にありません：クイックスタートは自己完結型です。

クイックスタートを初めて起動すると、JCR 対応のリポジトリ全体がバックグランドで作成されます。この処理に数分かかる場合があります。この初期起動が完了すると、リポジトリのインフラストラクチャは既に設定されているので、その後の起動処理はごく短時間で済みます。

多くの起動オプション（アクティブなポート番号、問題の AEM インスタンスをパブリッシュインスタンスとオーサーインスタンスのどちらにするか、など）は、クイックスタートファイルの名前を適宜変更することによって制御できます。この点に関するオプションのリストを確認するには、次のように、コマンドラインで「-help」を付けて JAR を実行します。

```shell
java -jar <quickstartfilename>.jar -help
```

**複製エージェント** — 複製エージェントは、作成者から発行環境へのコンテンツの発行（アクティブ化）に使用されるメカニズムとして、AEMの中心となります。ディスパッチャーのキャッシュからコンテンツをフラッシュします。発行環境から作成者環境に、ユーザー生成コンテンツ（フォーム入力など）を返します。

**足場** — 足場を使用すると、ページに必要な構造を反映したフィールドを持つフォーム（足場）を作成し、このフォームを使用して、この構造に基づいて簡単にページを作成できます。

**セグメント化** — サイト訪問者がサイトに来たときの興味と目標は異なります。 訪問者の目標を把握し、期待を満たすことは、オンラインマーケティングの重要な成功の前提条件です。 セグメント化によって訪問者の詳細を分析し、特徴付けることが成功の実現に役立ちます。

**サイドキック** — サイドキックは、編集可能なページに表示されるパレットのようなフローティングウィンドウです。新しいコンポーネントをドラッグしたり、ページに適用するアクションを実行したりできます。

**Site Catalyst** -SiteCatalystは、複数のマーケティングチャネルにわたるすべてのオンラインイニシアチブの統合データを、マーケティング担当者が1か所で測定、分析、最適化できるようにします。 Adobe SiteCatalystを使ってAEM Webサイトのデータを分析できます。

**Tarストレージ(TarMK)** - TarMKはAEMのデフォルトの永続性システムです。 AEM は、異なる永続化システム（MongoDB など）を使用するように設定できますが、TarMK には、一般的な JCR の使用例向けにパフォーマンスが最適化されており（そのため、非常に高速）、業界標準のデータ形式を使用し、すばやく簡単にバックアップできるという点で明白なメリットがあります。

**テンプレート** - AEMでは、テンプレートは特定のページタイプを指定します。 ページの構造を定義します（一方、通常はサムネール画像や様々なプロパティも指定します）。 例えば、製品ページ、サイトマップおよび問い合わせ先に、それぞれ別のテンプレートを使用することができます。

**ワークフロー** - AEMワークフローシステムを使用すると、ページやアセットを含む自動プロセスを作成できます。
