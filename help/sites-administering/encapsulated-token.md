---
title: カプセル化されたトークンのサポート
description: AEMでのカプセル化されたトークンのサポートについて説明します。
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: Security
content-type: reference
exl-id: e24d815c-83e2-4639-8273-b4c0a6bb008a
source-git-commit: 49688c1e64038ff5fde617e52e1c14878e3191e5
workflow-type: tm+mt
source-wordcount: '792'
ht-degree: 35%

---

# カプセル化されたトークンのサポート{#encapsulated-token-support}

## はじめに {#introduction}

デフォルトでは、AEMはトークン認証ハンドラーを使用して各要求を認証します。 ただし、認証要求を処理するには、トークン認証ハンドラーは要求ごとにリポジトリにアクセスする必要があります。 これは、認証状態の維持に cookie が使用されるためです。 論理的には、後続のリクエストを検証するために、状態をリポジトリに保持する必要があります。 つまり、認証メカニズムはステートフルです。

これは、水平的な拡張性に特に重要です。 以下に示すパブリッシュファームのようなマルチインスタンス設定では、最適な方法でロードバランシングを実現できません。 ステートフル認証では、永続化された認証状態は、ユーザーが最初に認証されたインスタンスでのみ使用できます。

![chlimage_1-33](assets/chlimage_1-33a.png)

例として、次のシナリオを考えてみましょう。

ユーザーはパブリッシュインスタンス 1 で認証される場合がありますが、後続のリクエストがパブリッシュインスタンス 2 に送られる場合、そのインスタンスはその永続認証状態を持ちません。これは、その状態がパブリッシュ 1 とパブリッシュ 2 に独自のリポジトリがあるからです。

この解決策は、ロードバランサーレベルでスティッキー接続を設定することです。 スティッキー接続を使用すると、ユーザーは常に同じパブリッシュインスタンスに向けられます。 その結果、真に最適なロードバランシングは実現できません。

パブリッシュインスタンスが使用できなくなった場合、そのインスタンスで認証されたすべてのユーザーのセッションが失われます。 これは、認証 cookie を検証するにはリポジトリへのアクセスが必要だからです。

## カプセル化されたトークンを使用したステートレス認証 {#stateless-authentication-with-the-encapsulated-token}

AEM の新しいカプセル化されたトークンサポートを使用したステートレス認証により、水平方向のスケーラビリティを確保できます。

カプセル化されたトークンは、AEM がリポジトリにアクセスすることなく、オフラインで安全に認証情報を作成および検証できるようにするための暗号化技術です。これにより、すべてのパブリッシュインスタンスで認証リクエストが発生し、スティッキー接続が不要になります。 また、認証のパフォーマンスを向上させる利点もあります。これは、リポジトリが認証要求ごとにアクセスする必要がないからです。

MongoMK オーサーインスタンスと TarMK パブリッシュインスタンスによる地理的に分散したデプロイメントでこれがどのように機能するかを以下に示します。

![chlimage_1-34](assets/chlimage_1-34a.png)

>[!NOTE]
>
>カプセル化されたトークンは認証に関するものです。 これにより、リポジトリにアクセスしなくても、Cookie を検証できます。 ただし、ユーザーがすべてのインスタンス上に存在し、そのユーザーの下に保存されている情報にすべてのインスタンスからアクセスできる必要があります。
>
>例えば、パブリッシュインスタンス番号 1 で新しいユーザーが作成された場合、カプセル化されたトークンの動作の仕組みにより、パブリッシュインスタンス番号 2 で正常に認証されます。 ユーザーが 2 番目のパブリッシュインスタンスに存在しない場合、要求は成功しません。
>

## カプセル化されたトークンの設定 {#configuring-the-encapsulated-token}

>[!NOTE]
>ユーザーを同期し、トークン認証（SAML や OAuth など）に依存するすべての認証ハンドラーは、次の場合、カプセル化されたトークンでのみ機能します。
>
>* スティッキーセッションが有効になっている、または
>
>* 同期の開始時に、AEM で既にユーザーが作成されている。つまり、同期プロセスの実行中にハンドラーがユーザーを&#x200B;**作成**&#x200B;するような状況では、暗号化されたトークンはサポートされません。

カプセル化されたトークンを設定する際には、次の点を考慮する必要があります。

1. 暗号化が関係するので、すべてのインスタンスに同じ HMAC キーが必要です。 AEM 6.3 以降、キー資料はリポジトリには格納されなくなり、実際のファイルシステムに格納されます。 この点を念頭に置いて、キーをレプリケートする最善の方法は、キーをレプリケート先のターゲットインスタンスのファイルシステムからコピーすることです。 詳しくは、以下の「HMAC キーのレプリケーション」を参照してください。
1. カプセル化されたトークンを有効にする必要があります。 これは、Web コンソールを通じておこなえます。

### HMAC キーのレプリケート {#replicating-the-hmac-key}

インスタンス間で鍵をレプリケートするには、次の操作が必要です。

1. コピーする鍵要素を含む AEM インスタンス（通常はオーサーインスタンス）にアクセスします。
1. ローカルファイルシステム内で、`com.adobe.granite.crypto.file` を見つけます。例えば、次のパスにあります。

   * `<author-aem-install-dir>/crx-quickstart/launchpad/felix/bundle25`

   各フォルダー内の `bundle.info` ファイルは、バンドル名を示します。 

1. データフォルダーに移動します。例：

   * `<author-aem-install-dir>/crx-quickstart/launchpad/felix/bundle25/data`

1. HMAC ファイルとマスターファイルをコピーします。
1. 次に、HMAC キーの複製先のターゲットインスタンスに移動し、データフォルダーにアクセスします。例：

   * `<publish-aem-install-dir>/crx-quickstart/launchpad/felix/bundle25/data`

1. 前の手順でコピーした 2 つのファイルを貼り付けます。
1. ターゲットインスタンスが既に実行されている場合は、[Crypto バンドルを更新](/help/communities/deploy-communities.md#refresh-the-granite-crypto-bundle)します。

1. 鍵のレプリケーション先のすべてのインスタンスに対して上記の手順を繰り返します。

#### カプセル化されたトークンの有効化 {#enabling-the-encapsulated-token}

HMAC 鍵がレプリケートされたら、Web コンソールを介してカプセル化されたトークンを有効化できます。

1. ブラウザーで `https://serveraddress:port/system/console/configMgr` を指定します。
1. **Adobe Granite トークン認証ハンドラー** というエントリを探してクリックします。
1. 次の画面で「**Enable encapsulated token support**」ボックスにチェックマークを入れて「**Save**」を押します。
