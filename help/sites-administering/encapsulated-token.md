---
title: カプセル化されたトークンのサポート
description: AEM でのカプセル化されたトークンのサポートについて説明します。
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: Security
content-type: reference
exl-id: e24d815c-83e2-4639-8273-b4c0a6bb008a
solution: Experience Manager, Experience Manager Sites
feature: Security
role: Admin
source-git-commit: 48d12388d4707e61117116ca7eb533cea8c7ef34
workflow-type: tm+mt
source-wordcount: '793'
ht-degree: 100%

---

# カプセル化されたトークンのサポート{#encapsulated-token-support}

## はじめに {#introduction}

デフォルトでは、AEM は各リクエストの認証にトークン認証ハンドラーを使用します。ただし、認証リクエストに対応するために、トークン認証ハンドラーはリクエストごとにリポジトリにアクセスする必要があります。これは、認証ステートを維持するのに Cookie が使用されるからです。理論上、後続のリクエストを検証するには、リポジトリに状態が保持される必要があります。要するに、認証メカニズムがステートフルであるということです。

これは、水平方向のスケーラビリティを確保するために特に重要です。以下のパブリッシュファームのようなマルチインスタンスの設定では、最適なロードバランシングは実現できません。ステートフル認証では、保持された認証ステートは、ユーザーが最初に認証されたインスタンスでのみ使用できます。

![chlimage_1-33](assets/chlimage_1-33a.png)

次のシナリオを例として使用します。

ユーザーはパブリッシュインスタンス 1 で認証できますが、後続のリクエストがパブリッシュインスタンス 2 に送られても、認証ステートはパブリッシュ 1 のリポジトリに保持されており、パブリッシュ 2 には独自のリポジトリがあるのでその保持された認証ステートを持ちません。

これを解決するには、ロードバランサーレベルでスティッキー接続を設定します。スティッキー接続を使用すると、ユーザーは常に同じパブリッシュインスタンスに送られます。その結果、真に最適なロードバランシングは実現しません。

あるパブリッシュインスタンスが使用できなくなると、そのインスタンスで認証されているすべてのユーザーのセッションが失われます。これは、認証 Cookie の検証にはリポジトリへのアクセスが必要なためです。

## カプセル化されたトークンを使用したステートレス認証 {#stateless-authentication-with-the-encapsulated-token}

AEM の新しいカプセル化されたトークンサポートを使用したステートレス認証により、水平方向のスケーラビリティを確保できます。

カプセル化されたトークンは、AEM がリポジトリにアクセスすることなく、オフラインで安全に認証情報を作成および検証できるようにするための暗号化技術です。この方法により、認証リクエストがすべてのパブリッシュインスタンスで行われるようになるので、スティッキー接続は不要です。また、認証リクエストごとにリポジトリにアクセスする必要がなくなるため、認証のパフォーマンスが向上するというメリットもあります。

MongoMK オーサーインスタンスと TarMK パブリッシュインスタンスによる地理的に分散したデプロイメントでこれがどのように機能するかを以下に示します。

![chlimage_1-34](assets/chlimage_1-34a.png)

>[!NOTE]
>
>カプセル化されたトークンは認証に使用されます。これにより、リポジトリにアクセスすることなく Cookie を確実に検証できます。ただし、ユーザーがすべてのインスタンスに存在し、そのユーザーに保存された情報にすべてのインスタンスがアクセスできる必要があります。
>
>例えば、パブリッシュインスタンス 1 に新しく作成されたユーザーは、カプセル化されたトークンにより、パブリッシュインスタンス 2 でも正常に認証されます。そのユーザーがパブリッシュインスタンス 2 に存在しない場合、リクエストは失敗します。
>

## カプセル化されたトークンの設定 {#configuring-the-encapsulated-token}

>[!NOTE]
>ユーザーを同期し、トークン認証（SAML や OAuth など）に依存するすべての認証ハンドラーは、次の場合、カプセル化されたトークンでのみ機能します。
>
>* スティッキーセッションが有効になっている、または
>
>* 同期の開始時に、AEM で既にユーザーが作成されている。つまり、同期プロセスの実行中にハンドラーがユーザーを&#x200B;**作成**&#x200B;するような状況では、暗号化されたトークンはサポートされません。

カプセル化されたトークンを設定する際には、いくつかの点を考慮する必要があります。

1. 関与する暗号作成技術により、すべてのインスタンスに同じ HMAC 鍵が必要です。AEM 6.3 以降、鍵要素はリポジトリではなく、実際のファイルシステムに保存されます。したがって、鍵をレプリケーションするのに最適な方法は、ソースインスタンスのファイルシステムから、鍵のレプリケーション先となるターゲットインスタンスのファイルシステムに鍵要素をコピーすることです。詳しくは、次の「HMAC 鍵のレプリケーション」を参照してください。
1. カプセル化されたトークンを有効にする必要があります。これは Web コンソールで実行できます。

### HMAC 鍵のレプリケーション {#replicating-the-hmac-key}

インスタンス間で鍵をレプリケーションするには、次の手順に従います。

1. コピーする鍵要素を含む AEM インスタンス（通常はオーサーインスタンス）にアクセスします。
1. ローカルファイルシステム内で、`com.adobe.granite.crypto.file` を見つけます。例えば、次のパスにあります。

   * `<author-aem-install-dir>/crx-quickstart/launchpad/felix/bundle25`

   各フォルダー内の `bundle.info` ファイルは、バンドル名を示します。 

1. データフォルダーに移動します。例：

   * `<author-aem-install-dir>/crx-quickstart/launchpad/felix/bundle25/data`

1. HMAC ファイルとマスターファイルをコピーします。
1. 次に、HMAC キーの複製先のターゲットインスタンスに移動し、データフォルダーにアクセスします。例：

   * `<publish-aem-install-dir>/crx-quickstart/launchpad/felix/bundle25/data`

1. 前の手順でコピーした 2 つのファイルを貼り付けます。
1. ターゲットインスタンスが既に実行されている場合は、[Crypto バンドルを更新](/help/communities/deploy-communities.md#refresh-the-granite-crypto-bundle)します。

1. 鍵のレプリケーション先のすべてのインスタンスに対して上記の手順を繰り返します。

#### カプセル化されたトークンの有効化 {#enabling-the-encapsulated-token}

HMAC 鍵がレプリケートされたら、Web コンソールを介してカプセル化されたトークンを有効化できます。

1. ブラウザーで `https://serveraddress:port/system/console/configMgr` を指定します。
1. **Adobe Granite トークン認証ハンドラー** というエントリを探してクリックします。
1. 次の画面で「**Enable encapsulated token support**」ボックスにチェックマークを入れて「**Save**」を押します。
