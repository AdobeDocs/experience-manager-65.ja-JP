---
title: ユーザー、グループおよびアクセス権限の管理
description: Adobe Experience Managerでのユーザー、グループ、アクセス権の管理について説明します。
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: Security
content-type: reference
docset: aem65
exl-id: 5808b8f9-9b37-4970-b5c1-4d33404d3a8b
feature: Security
source-git-commit: 6799f1d371734b69c547f3c0c68e1e633aa63229
workflow-type: tm+mt
source-wordcount: '3101'
ht-degree: 67%

---

# ユーザー、グループ、アクセス権の管理{#user-group-and-access-rights-administration}

CRX リポジトリへのアクセスの有効化に関連するトピックは以下のとおりです。

* [アクセス権](#how-access-rights-are-evaluated) - 定義および評価方法に関する概念
* [ユーザー管理](#user-administration) - アクセスに使用する個々のアカウントの管理
* [グループ管理](#group-administration) - グループの作成によるユーザー管理の簡略化
* [アクセス権限の管理](#access-right-management) - ユーザーとグループがリソースにアクセスする方法を制御するポリシーの定義

基本的な要素：

**ユーザーアカウント** - CRX は、ユーザーアカウントに保持されている詳細に従って（そのユーザーまたは他のアプリケーションによって）ユーザーを識別および検証することで、アクセスを認証します。

CRX では、すべてのユーザーアカウントはワークスペース内のノードです。 CRX ユーザーアカウントには次のプロパティがあります。

* CRX の 1 人のユーザーを表します。
* ユーザー名とパスワードが格納されます。
* そのワークスペースに適用できます。
* サブユーザーを含めることはできません。 階層アクセス権の場合は、グループを使用する必要があります。

* ユーザーアカウントのアクセス権限を指定できます。

  ただし、管理を簡略化するために、Adobeでは（ほとんどの場合）アクセス権をグループアカウントに割り当てることをお勧めします。 個々のユーザーにアクセス権を割り当てると、管理が難しくなります（ただし、1 つまたは 2 つのインスタンスしか存在しない場合は、特定のシステムユーザーが該当します）。

**グループアカウント**  — グループアカウントは、ユーザーや他のグループの集まりです。 グループに割り当てられたアクセス権の変更は、そのグループ内のすべてのユーザーに自動的に適用されるので、グループを使用すると管理を簡略化できます。ユーザーはグループに属している必要はありませんが、多くの場合、複数のグループに属しています。

CRX では、グループには次のプロパティがあります。

* 共通のアクセス権を持つユーザーのグループを表します。例えば、作成者や開発者などです。
* そのワークスペースに適用できます。
* メンバーを持つことができます。メンバーには、個々のユーザーや他のグループを指定できます。
* 階層構造のグループ化は、メンバーの関係を使用することで実現できます。リポジトリ内の別のグループの直下にグループを配置することはできません。
* すべてのグループメンバーのアクセス権を定義できます。

**アクセス権** - CRX は、アクセス権を使用して、リポジトリの特定の領域へのアクセスを制御します。

そのためには、リポジトリ内のリソース（ノードまたはパス）へのアクセスを許可または拒否する権限を割り当てます。割り当てることのできる権限は様々なので、権限を評価して、現在の要求に適用可能な組み合わせを判断する必要があります。

CRX では、ユーザーアカウントとグループアカウントの両方にアクセス権を設定できます。 その後、同じ評価の基本原則を両方に適用します。

## アクセス権限の評価方法 {#how-access-rights-are-evaluated}

>[!NOTE]
>
>CRX は、[JSR-283 で定義されるアクセス制御](https://developer.adobe.com/experience-manager/reference-materials/spec/jcr/2.0/16_Access_Control_Management.html)を実装しています。
>
>CRX リポジトリの標準インストールは、リソースベースのアクセス制御リストを使用するように設定されます。これは、JSR-283 アクセス制御の実装と、Jackrabbit に存在する実装の 1 つとして考えられます。

### 件名とプリンシパル {#subjects-and-principals}

CRX では、次に示す 2 つの主要な概念を使用してアクセス権限を評価します。

* **プリンシパル**&#x200B;は、アクセス権を持つエンティティです。プリンシパルには次が含まれます。

   * ユーザーアカウント
   * グループアカウント

     ユーザーアカウントが 1 つ以上のグループに属する場合は、各グループプリンシパルにも関連付けられます。

* **サブジェクト**&#x200B;は、リクエストのソースを表すために使用されます。

  リクエストに適用されるアクセス権を統合するために使用されます。これらは次の場所から取得されます。

   * ユーザープリンシパル

     ユーザーアカウントに直接割り当てる権限。

   * ユーザーに関連付けられているすべてのグループプリンシパル

     すべての権限は、ユーザーが属する任意のグループに割り当てられます。

  結果は、リクエストされたリソースへのアクセスを許可または拒否するために使用されます。

#### サブジェクトのアクセス権限のリストを編集する {#compiling-the-list-of-access-rights-for-a-subject}

CRX では、件名は次の項目に依存します。

* ユーザープリンシパル
* そのユーザーに関連付けられているすべてのグループプリンシパル

サブジェクトに適用可能なアクセス権限のリストは、以下の要素から構成されます。

* ユーザーアカウントに直接割り当てる権限
* ユーザーが属するいずれかのグループに割り当てられているすべての権限

![chlimage_1-56](assets/chlimage_1-56.png)

>[!NOTE]
>
>* CRX では、リストを編集する際に、ユーザー階層が考慮されません。
>* CRX では、グループを別のグループのメンバーとして含める場合にのみ、グループ階層を使用します。グループの権限は自動的に継承されません。
>* グループを指定する順序は、アクセス権限に影響しません。
>

### リクエストの解決とアクセス権限 {#resolving-request-and-access-rights}

CRX が要求を処理する際に、主体からのアクセス要求とリポジトリノード上のアクセス制御リストを比較します。

次の図は、Linda が次のリポジトリ構造内の `/features` ノードの更新を要求する場合の処理を示しています。

![chlimage_1-57](assets/chlimage_1-57.png)

### 優先順位 {#order-of-precedence}

CRX のアクセス権限は次のように評価されます。

* 以下に関係なく、ユーザープリンシパルは常にグループプリンシパルよりも優先されます。

   * アクセス制御リスト内の順序
   * ノード階層内の位置

* 特定のプリンシパルに対して、特定のノードに deny エントリと allow エントリが（最大で）1 つ存在します。 冗長なエントリは常に実装によってクリアされ、allow エントリと deny エントリに同じ権限が示されることはありません。

>[!NOTE]
>
>この評価プロセスは、標準の CRX インストールのリソースベースのアクセス制御に適しています。

ユーザー `aUser` がグループ `aGroup` のメンバーである 2 つの例を次に示します。

```xml
   + parentNode
     + acl
       + ace: aUser - deny - write
     + childNode
       + acl
         + ace: aGroup - allow - write
       + grandChildNode
```

この場合、次のようになります。

* `aUser` には `grandChildNode` に対する書き込み権限が付与されません。

```xml
   + parentNode
     + acl
       + ace: aUser - deny - write
     + childNode
       + acl
         + ace: aGroup - allow - write
         + ace: aUser - deny - write
       + grandChildNode
```

この場合の解決策は、次のとおりです。

* `aUser` には `grandChildNode` に対する書き込み権限が付与されません。
* `aUser` の 2 つ目の ACE は冗長になります。


複数のグループプリンシパルのアクセス権限は、階層内および単一のアクセス制御リスト内の両方で、その順序に基づいて評価されます。

### ベストプラクティス {#best-practices}

いくつかの推奨事項とベストプラクティスを次の表に示します。

<table>
 <tbody>
  <tr>
   <td>推奨...</td>
   <td>理由...</td>
  </tr>
  <tr>
   <td><i>グループを使用する</i></td>
   <td><p>アクセス権限をユーザーごとに割り当てないようにします。その理由は次の通りです。</p>
    <ul>
     <li>グループ数よりもユーザー数の方がはるかに多く、グループを使用すると構造が簡素化されます。</li>
     <li>グループはアカウント全体の概要を確認するのに役立ちます。</li>
     <li>グループを使用すると、継承が簡単になります。</li>
     <li>ユーザーは頻繁に追加および削除されます。グループは長期的に使用されます。</li>
    </ul> </td>
  </tr>
  <tr>
   <td><i>ポジティブに</i></td>
   <td><p>グループプリンシパルのアクセス権限を指定するには、（可能な限り）常に「許可」ステートメントを使用します。「拒否」ステートメントの使用は避けてください。</p> <p>グループプリンシパルは、階層内でも、単一のアクセス制御リスト内でも順番に評価されます。</p> </td>
  </tr>
  <tr>
   <td><i>シンプルに</i></td>
   <td><p>新しいインストールを設定する際に時間を費やし、考慮すると、十分な費用がかかります。</p> <p>明確な構造を適用すると、継続的なメンテナンスと管理が簡単になり、現在の同僚や将来の後継者も、実装されている内容を容易に理解できます。</p> </td>
  </tr>
  <tr>
   <td><i>テスト</i></td>
   <td>練習のためのテストインストールを利用して、様々なユーザーとグループ間の関係を把握してください。</td>
  </tr>
  <tr>
   <td><i>デフォルトのユーザー／グループ</i></td>
   <td>セキュリティ上の問題を防ぐために、必ずインストール直後にデフォルトのユーザーとグループを更新してください。</td>
  </tr>
 </tbody>
</table>

## ユーザー管理 {#user-administration}

標準ダイアログは&#x200B;**ユーザー管理**&#x200B;に使用されます。

適切なワークスペースにログインする必要があり、ログインすると、次の両方の場所からダイアログにアクセスできるようになります。

* CRX のメインコンソールの&#x200B;**ユーザー管理**&#x200B;リンク
* CRX Explorer の&#x200B;**セキュリティ**&#x200B;メニュー

![chlimage_1-58](assets/chlimage_1-58.png)

**プロパティ**

* **UserID**

  CRX にアクセスする際に、アカウントの短縮名が使用されます。

* **プリンシパル名**

  アカウントの完全な名前。

* **パスワード**

  このアカウントを使用して CRX にアクセスする場合に必要です。

* **ntlmhash**

  
新しい各アカウントに自動的に割り当てられます。パスワードが変更されると更新されます。

* 名前、タイプ、値を定義して新しいプロパティを追加できます。新しいプロパティごとに「保存」（緑色のチェックマーク）をクリックします。

**グループのメンバーシップ**

アカウントが属しているすべてのグループが表示されます。「継承」列は、別のグループのメンバーシップの結果として継承されたメンバーシップを示します。

GroupID をクリックすると（利用可能な場合）、 [グループ管理](#group-administration) そのグループに対して

**実行**

別のユーザーとして実行する機能では、ユーザーは別のユーザーに成り代わって作業を行うことができます。

つまり、ユーザーアカウントは、自分のアカウントで操作できる他のアカウント（ユーザーまたはグループ）を指定できます。 つまり、user-B が user-A としての実行を許可されている場合、user-B は user-A のアカウントの詳細（ID、名前、アクセス権を含む）全体を使用して行動できます。

これにより、偽装アカウントは、不在時や過剰な負荷の短期間を共有するなど、偽装しているアカウントを使用しているかのようにタスクを完了できます。

アカウントが別のアカウントになりすましている場合、表示が困難です。 ログファイルには、そのイベントで、別のユーザーとして実行されたという事実に関する情報は含まれません。したがって、user-B が user-A として実行している場合、すべてのイベントは、user-A が個人的に実行したものと見なすことができます。

### ユーザーアカウントの作成 {#creating-a-user-account}

1. **ユーザー管理**&#x200B;ダイアログを開きます。
1. 「**ユーザーを作成**」をクリックします。
1. 次に、以下のプロパティを入力できます。

   * **ユーザー ID**：アカウント名として使用されます。
   * **パスワード**：ログイン時に必要です。
   * **プリンシパル名**：完全な名前を指定します。
   * **中間パス**：ツリー構造を作成するために使用できます。

1. [ 保存 ] （緑のチェックマーク）をクリックします。
1. 次の操作を実行できるようにダイアログボックスが展開されます。

   1. **プロパティ**&#x200B;を設定します。
   1. 「**グループのメンバーシップ**」を確認します。
   1. **実行**&#x200B;を定義します。

>[!NOTE]
>
>以下の項目の数がどちらも多いインストール環境で新しいユーザーを登録すると、パフォーマンスが低下する場合があります。
>
>* ユーザー
>* 多数のメンバーを持つグループ
>

### ユーザーアカウントの更新 {#updating-a-user-account}

1. を使用 **ユーザー管理** ダイアログボックスで、すべてのアカウントのリスト表示を開きます。
1. ツリー構造内を移動します。
1. 必要なアカウントをクリックして、編集用に開くことができます。
1. 変更を加え、そのエントリの [ 保存 ] （緑のチェックマーク）をクリックします。
1. 「**閉じる**」をクリックして終了するか、「**リスト...**」をクリックしてすべてのユーザーアカウントのリストに戻ります。

### ユーザーアカウントの削除 {#removing-a-user-account}

1. を使用 **ユーザー管理** ダイアログボックスで、すべてのアカウントのリスト表示を開きます。
1. ツリー構造内を移動します。
1. 必要なアカウントを選択し、 **ユーザーを削除**。アカウントは直ちに削除されます。

>[!NOTE]
>
>これにより、このプリンシパルのノードがリポジトリから削除されます。
>
>アクセス権限のエントリは削除されません。これにより、履歴の整合性が確保されます。

### プロパティの定義 {#defining-properties}

新規または既存のアカウントの&#x200B;**プロパティ**&#x200B;を定義できます。

1. 適切なアカウントの&#x200B;**ユーザー管理**&#x200B;ダイアログを開きます。
1. **プロパティ**&#x200B;名を定義します。
1. ドロップダウンリストから「**タイプ**」を選択します。
1. **値**&#x200B;を定義します。
1. 新しいプロパティの「保存」（緑色のチェックマーク）をクリックします。

既存のプロパティは、ごみ箱アイコンを使用して削除できます。

パスワードを除き、プロパティは編集できません。プロパティは削除してから再作成する必要があります。

#### パスワードの変更 {#changing-the-password}

The **パスワード** は、 **パスワードを変更** リンク。

CRX Explorer の&#x200B;**セキュリティ**&#x200B;メニューからパスワードを自分のユーザーアカウントに変更することもできます。

### 偽装の定義 {#defining-an-impersonator}

新規または既存のアカウントを他のユーザーとして実行するユーザーを定義できます。

1. 適切なアカウントの&#x200B;**ユーザー管理**&#x200B;ダイアログを開きます。
1. 別のユーザーとして実行を許可するアカウントを指定します。

   「参照...」を使用して、既存のアカウントを選択できます。

1. 新しいプロパティの「保存」（緑色のチェックマーク）をクリックします。

## グループ管理 {#group-administration}

**グループ管理**&#x200B;には標準ダイアログが使用されます。

適切なワークスペースにログインする必要があり、ログインすると、次の両方の場所からダイアログにアクセスできるようになります。

* CRX のメインコンソールの&#x200B;**グループ管理**&#x200B;リンク
* CRX Explorer の&#x200B;**セキュリティ**&#x200B;メニュー

![chlimage_1-8](assets/chlimage_1-8.jpeg)

**プロパティ**

* **GroupID**

  グループアカウントの省略名。

* **プリンシパル名**

  グループアカウントの完全な名前。

* 名前、タイプ、値を定義して新しいプロパティを追加できます。新しいプロパティごとに「保存」（緑色のチェックマーク）をクリックします。

* **メンバー**

  グループのメンバーとして、ユーザーまたは他のグループを追加できます。

**グループのメンバーシップ**

現在のグループアカウントが属しているすべてのグループが表示されます。「継承」列は、別のグループのメンバーシップの結果として継承されたメンバーシップを示します。

GroupID をクリックすると、そのグループのダイアログボックスが開きます。

**メンバー**

現在のグループのメンバーであるすべてのアカウント（ユーザーまたはグループ）が一覧表示されます。

**継承**&#x200B;列は、別のグループのメンバーシップの結果として継承されたメンバーシップを示します。

>[!NOTE]
>
>いずれかのアセットフォルダーでユーザーに対して所有者、編集者または閲覧者の役割が割り当てられると、新しいグループが作成されます。役割が定義された各フォルダーのグループ名は `mac-default-<foldername>` の形式となります。

### グループアカウントの作成 {#creating-a-group-account}

1. を開きます。 **グループ管理** ダイアログボックス。
1. 「**グループを作成**」をクリックします。
1. 次に、以下のプロパティを入力できます。

   * **プリンシパル名**：完全な名前を指定します。
   * **中間パス**：ツリー構造を作成するために使用できます。

1. [ 保存 ] （緑のチェックマーク）をクリックします。
1. ダイアログボックスが展開され、次の操作が可能になります。

   1. **プロパティ**&#x200B;を設定します。
   1. 「**グループのメンバーシップ**」を確認します。
   1. **メンバー**&#x200B;を管理します。

### グループアカウントの更新 {#updating-a-group-account}

1. を使用 **グループ管理** ダイアログボックスで、すべてのアカウントのリスト表示を開きます。
1. ツリー構造内を移動します。
1. 必要なアカウントをクリックして、編集用に開くことができます。
1. 変更を加え、そのエントリの [ 保存 ] （緑のチェックマーク）をクリックします。
1. 「**閉じる**」をクリックして終了するか、「**リスト...**」をクリックしてすべてのグループアカウントのリストに戻ります。

### グループアカウントの削除 {#removing-a-group-account}

1. を使用 **グループ管理** ダイアログボックスで、すべてのアカウントのリスト表示を開きます。
1. ツリー構造内を移動します。
1. 必要なアカウントを選択し、 **グループを削除**。アカウントは直ちに削除されます。

>[!NOTE]
>
>これにより、このプリンシパルのノードがリポジトリから削除されます。
>
>アクセス権限のエントリは削除されません。これにより、履歴の整合性が確保されます。

### プロパティの定義 {#defining-properties-1}

新規または既存のアカウントのプロパティを定義できます。

1. 適切なアカウントの&#x200B;**グループ管理**&#x200B;ダイアログを開きます。
1. **プロパティ**&#x200B;名を定義します。
1. ドロップダウンリストから「**タイプ**」を選択します。
1. **値**&#x200B;を定義します。
1. 新しいプロパティの「保存」（緑色のチェックマーク）をクリックします。

既存のプロパティは、ごみ箱アイコンを使用して削除できます。

### メンバー {#members}

現在のグループにメンバーを追加できます。

1. 適切なアカウントの&#x200B;**グループ管理**&#x200B;ダイアログを開きます。
1. 以下のどちらかの操作を行います。

   * 必要なメンバーの名前（ユーザーまたはグループアカウント）を入力します。
   * または「**参照...**」を使用して、追加するプリンシパル（ユーザーまたはグループアカウント）を検索し、選択します。

1. 新しいプロパティの「保存」（緑色のチェックマーク）をクリックします。

または、ごみ箱アイコンを使用して既存のメンバーを削除します。

## アクセス権限の管理 {#access-right-management}

を使用 **アクセス制御** CRXDE Liteの「 」タブでは、アクセス制御ポリシーを定義し、関連する権限を割り当てることができます。

例： **現在のパス** 左側のウィンドウで必要なリソースを選択し、右下のウィンドウの「アクセス制御」タブを選択します。

![crx_accesscontrol_tab](assets/crx_accesscontrol_tab.png)

ポリシーは次のように分類されます。

* **適用可能なアクセス制御ポリシー**

  これらのポリシーは適用できます。

  これらのポリシーは、ローカルポリシーの作成に使用できます。適用可能なポリシーを選択して追加すると、そのポリシーはローカルポリシーになります。

* **ローカルアクセス制御ポリシー**

  これらは、適用したアクセス制御ポリシーです。このポリシーの更新、並べ替えまたは削除を行うことができます。

  ローカルポリシーは、親から継承されたポリシーを上書きします。

* **有効なアクセス制御ポリシー**

  アクセス要求に対して有効なアクセス制御ポリシーです。ローカルポリシーおよび親から継承したポリシーから派生した集計ポリシーが表示されます。

### ポリシーの選択 {#policy-selection}

次の項目用のポリシーを選択できます。

* **現在のパス**

  前述の例では、リポジトリ内のリソースを選択します。この「現在のパス」のポリシーが表示されます。

* **リポジトリ**

  リポジトリレベルのアクセス制御を選択します。例えば、ノードではなくリポジトリにのみ関連する `jcr:namespaceManagement` 権限を設定する場合などに使用します。

* **プリンシパル**

  リポジトリに登録されているプリンシパルです。

  次のいずれかを入力します。 **プリンシパル** フィールドの右側にあるアイコンに名前を付けるかクリックして、 **プリンシパルを選択** ダイアログボックス。

  これにより、 **検索** の **ユーザー** または **グループ化**. 表示されたリストから必要なプリンシパルを選択し、「 」をクリックします。 **OK** 値を前のダイアログボックスに戻す場合。

![crx_accesscontrol_selectprincipal](assets/crx_accesscontrol_selectprincipal.png)

>[!NOTE]
>
>管理を簡略化するため、Adobeは、個々のユーザーアカウントではなく、グループアカウントにアクセス権を割り当てることをお勧めします。
>
>多数のユーザーアカウントよりも、少数のグループの方が管理しやすくなります。

### 権限 {#privileges}

アクセス制御エントリを追加する場合は、以下に示す権限を選択できます（詳しくは、[セキュリティ API](https://developer.adobe.com/experience-manager/reference-materials/spec/javax.jcr/javadocs/jcr-2.0/javax/jcr/security/Privilege.html) に関するページを参照）。

<table>
 <tbody>
  <tr>
   <th><strong>権限名</strong></th>
   <th><strong>制御する権限</strong></th>
  </tr>
  <tr>
   <td><code>jcr:read</code></td>
   <td>ノードを取得して、そのプロパティと値を読み取ります。</td>
  </tr>
  <tr>
   <td><code>rep:write</code></td>
   <td>これは、jcr:write および jcr:nodeTypeManagement の Jackrabbit 固有の集計権限です。<br /> </td>
  </tr>
  <tr>
   <td><code>jcr:all</code></td>
   <td>他の事前定義済み権限がすべて含まれる集計権限です。</td>
  </tr>
  <tr>
   <td><strong>詳細</strong></td>
   <td> </td>
  </tr>
  <tr>
   <td><code>crx:replicate</code></td>
   <td>ノードのレプリケーションを実行します。</td>
  </tr>
  <tr>
   <td><code>jcr:addChildNodes</code></td>
   <td>ノードの子ノードを作成します。</td>
  </tr>
  <tr>
   <td><code>jcr:lifecycleManagement</code></td>
   <td>ノード上でライフサイクル操作を実行します。</td>
  </tr>
  <tr>
   <td><code>jcr:lockManagement</code></td>
   <td>ノードをロックおよびロック解除します。ロックを更新します。</td>
  </tr>
  <tr>
   <td><code>jcr:modifyAccessControl</code></td>
   <td>ノードのアクセス制御ポリシーを変更します。</td>
  </tr>
  <tr>
   <td><code>jcr:modifyProperties</code></td>
   <td>ノードのプロパティを作成、変更、削除します。</td>
  </tr>
  <tr>
   <td><code>jcr:namespaceManagement</code></td>
   <td>名前空間定義を登録、登録解除、変更します。</td>
  </tr>
  <tr>
   <td><code>jcr:nodeTypeDefinitionManagement</code></td>
   <td>ノードタイプ定義をリポジトリに読み込みます。</td>
  </tr>
  <tr>
   <td><code>jcr:nodeTypeManagement</code></td>
   <td>mixin ノードタイプを追加および削除し、ノードのプライマリノードタイプを変更します。また、Node.addNode および XML 読み込みメソッドの呼び出しも含まれ、mixin または新しいノードのプライマリ型が明示的に指定されます。</td>
  </tr>
  <tr>
   <td><code>jcr:readAccessControl</code></td>
   <td>ノードのアクセス制御ポリシーを読み取ります。</td>
  </tr>
  <tr>
   <td><code>jcr:removeChildNodes</code></td>
   <td>ノードの子ノードを削除します。</td>
  </tr>
  <tr>
   <td><code>jcr:removeNode</code></td>
   <td>ノードを削除します。</td>
  </tr>
  <tr>
   <td><code>jcr:retentionManagement</code></td>
   <td>ノード上で保持管理操作を実行します。</td>
  </tr>
  <tr>
   <td><code>jcr:versionManagement</code></td>
   <td>ノード上でバージョン管理操作を実行します。</td>
  </tr>
  <tr>
   <td><code>jcr:workspaceManagement</code></td>
   <td>JCR API によるワークスペースの作成と削除。</td>
  </tr>
  <tr>
   <td><code>jcr:write</code></td>
   <td>次の権限が含まれる集計権限です。<br />
- jcr:modifyProperties<br />
- jcr:addChildNodes<br />
- jcr:removeNode<br />
- jcr:removeChildNodes</td>
  </tr>
  <tr>
   <td><code>rep:privilegeManagement</code></td>
   <td>新しい権限を登録します。</td>
  </tr>
 </tbody>
</table>

### 新しい権限の登録 {#registering-new-privileges}

新しい権限を登録することもできます。

1. ツールバーで、「 」を選択します。 **ツール**&#x200B;を、 **権限** ：現在登録されている権限を表示します。

   ![ac_privileges](assets/ac_privileges.png)

1. 以下を使用します。 **登録権限** アイコン (**+**) を使用して、次の権限を定義できます。

   ![ac_privilegeregister](assets/ac_privilegeregister.png)

1. 「**OK**」をクリックして保存します。これで、権限を選択できるようになります。

### アクセス制御エントリの追加 {#adding-an-access-control-entry}

1. リソースを選択して「**アクセス制御**」タブを開きます。

1. 新しい&#x200B;**ローカルアクセス制御ポリシー**&#x200B;を追加するには、「**適用可能なアクセス制御ポリシー**」リストの右側にある **+** アイコンをクリックします。

   ![crx_accesscontrol_applicable](assets/crx_accesscontrol_applicable.png)

1. 新しいエントリが「**「ローカルアクセス制御ポリシー**」の下に表示されます。。

   ![crx_accesscontrol_newlocal](assets/crx_accesscontrol_newlocal.png)

1. 次をクリック： **+** アイコンを使用して、次の項目を追加できます。

   ![crx_accesscontrol_addentry](assets/crx_accesscontrol_addentry.png)

   >[!NOTE]
   >
   >現時点では、空の文字列を指定するには対策が必要です。
   >
   >この場合、 `""`.

1. アクセス制御ポリシーを定義し、「**OK**」をクリックして保存します。新しいポリシーは次のとおりです。

   * 次の場所にリストされます： **ローカルアクセス制御ポリシー**
   * 変更が **有効なアクセス制御ポリシー**.

CRX は選択を検証します。特定のプリンシパルに対しては、特定のノードに対して deny エントリと allow エントリが（最大で）1 つ存在します。 冗長なエントリは常に実装によってクリアされ、allow エントリと deny エントリに同じ権限が示されることはありません。

### ローカルアクセス制御ポリシーの順序付け {#ordering-local-access-control-policies}

リスト内の順序は、ポリシーの適用順序を示します。

1. のテーブル内 **ローカルアクセス制御ポリシー**&#x200B;必要なエントリを選択し、テーブル内の新しい位置にドラッグします。

   ![crx_accesscontrol_reorder](assets/crx_accesscontrol_reorder.png)

1. 変更は、 **ローカル** そして **有効なアクセス制御ポリシー**.

### アクセス制御ポリシーの削除 {#removing-an-access-control-policy}

1. のテーブル内 **ローカルアクセス制御ポリシー**&#x200B;をクリックし、エントリの右側にある赤いアイコン (-) をクリックします。
1. エントリが、 **ローカル** そして **有効なアクセス制御ポリシー**.

### アクセス制御ポリシーのテスト {#testing-an-access-control-policy}

1. CRXDE Liteツールバーで、 **ツール**&#x200B;を、 **アクセス制御のテスト…**.
1. 右上のウィンドウに新しいダイアログが開きます。 を選択します。 **パス** および/または **プリンシパル** テストしたいと思う
1. 「**テスト**」をクリックして選択項目の結果を確認します。

   ![crx_accesscontrol_test](assets/crx_accesscontrol_test.png)
